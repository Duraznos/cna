<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.1.1 (Build 702U)" ts="2014-08-07 18:08:39">
<Class name="CNA.Tests">
<Super>%UnitTest.TestCase</Super>
<TimeChanged>63404,43962.583872</TimeChanged>
<TimeCreated>63384,43091.390095</TimeCreated>

<Property name="CNAPath">
<Type>%String</Type>
</Property>

<Property name="testLib">
<Type>%String</Type>
</Property>

<Property name="Hunspell">
<Type>%String</Type>
</Property>

<Property name="HunspellAff">
<Type>%String</Type>
</Property>

<Property name="HunspellDic">
<Type>%String</Type>
</Property>

<Property name="Ulysses">
<Type>%String</Type>
</Property>

<Method name="TestLowLevel">
<Implementation><![CDATA[
	try {
		do $$$AssertEquals(##class(%File).Exists(..CNAPath), 1, "CNA file exists")
		do $$$AssertEquals(##class(%File).Exists(..testLib), 1, "Testlib file exists")
	
		do $zf(-3, ..CNAPath)
		
		set libID = $zf(-3, "", "load_library", ..testLib)
		
		set func = "sum"
		set argTypes = $CHAR(3, 3, 3, 3, 3, 3)
		set args = $ZLCHAR(12, 10, 35, 321, 21)
		set retVal = $zf(-3, "", "call_function", libID, func, argTypes, args)
		set retVal = $ZLASCII(retVal)
		do $$$AssertEquals(retVal, 399, "Check sum() from test library: 12 + 10 + 35 + 321 + 21 = 399")
		
		set func = "mul"
		set argTypes = $CHAR(9, 12, 12)
		set args = $ZQCHAR(10) _ $ZDCHAR($DOUBLE(1.5))
		set retVal = $zf(-3, "", "call_function", libID, func, argTypes, args)
		set retVal = $ZDASCII(retVal)
		do $$$AssertEquals(retVal, $double(15), "Check mul() from test library: 10 * 1.5 = 15")

		set func = "x"
		set argTypes = $CHAR(9, 9)
		set args = $ZQCHAR(-2384929929829)
		set retVal = $zf(-3, "", "call_function", libID, func, argTypes, args)
		set retVal =  $ZQASCII(retVal)
		do $$$AssertEquals(retVal, -2384929929829, "Check x() from test library:" _ retVal _ " = -2384929929829")
		
		set func = "square"
		set argTypes = $CHAR(12, 12)
		set args = $ZDCHAR($DOUBLE(1.2))
		set retVal = $zf(-3, "", "call_function", libID, func, argTypes, args)
		set retVal = $ZDASCII(retVal)
		do $$$AssertEquals(retVal, $double(1.44), "Check square() from test library: 1.2 ^ 2 = 1.44")
		
		do $zf(-3, "", "free_library", libID)
		
	}catch ex {

		write $system.Status.GetErrorText(ex.AsStatus(),"ru"),!
		do $zf(-3, "")
		do $$$AssertEquals(0, 1, "Exception were catched")
	}
]]></Implementation>
</Method>

<Method name="TestAPI">
<Implementation><![CDATA[
	try {
		do $$$AssertEquals(##class(%File).Exists(..testLib), 1, "testLib file exists")

		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(cna.#INT64)
		do argTypes.Insert(cna.#DOUBLE)
		set retVal = cna.CallFunction("mul", cna.#DOUBLE, argTypes, 10, $double(1.5))
		do $$$AssertEquals(retVal, $double(15), "Check return value of mul()")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#DOUBLE)
		set retVal = cna.CallFunction("square", cna.#DOUBLE, argTypes, $double(12341.12311))
		do $$$AssertEquals(retVal, $double(12341.12311) * $double(12341.12311), "Check return value of square()")

		do argTypes.Clear()
		do argTypes.Insert(cna.#UINT)
		do argTypes.Insert(cna.#UINT)
		do argTypes.Insert(cna.#UINT)
		do argTypes.Insert(cna.#UINT)
		do argTypes.Insert(cna.#UINT)
		set retVal = cna.CallFunction("sum", cna.#UINT, argTypes, 1243, 1231, 121, 12123, 121)
		do $$$AssertEquals(retVal, 1243 + 1231 + 121 + 12123 + 121, "Check return value of sum()")

		do argTypes.Clear()
		set retVal = cna.CallFunction("five", cna.#INT, argTypes)
		do $$$AssertEquals(retVal, 5, "Check return value of five()")

		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestHunspell">
<Implementation><![CDATA[
	try {
		if ($SYSTEM.Version.GetOS() = "UNIX") {
			//Not implemented yet
			return $$$OK
		} 
		
		
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..Hunspell)
		
		set aff = cna.ConvertStringToPointer(..HunspellAff)
		set dic = cna.ConvertStringToPointer(..HunspellDic)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(cna.#POINTER)
		do argTypes.Insert(cna.#POINTER)
		
		set hunspell =  cna.CallFunction("Hunspell_create", cna.#POINTER, argTypes, aff, dic)
		
		set bad  =  cna.ConvertStringToPointer($ZCVT("лымузин", "O", "UTF8"))
		set good =  cna.ConvertStringToPointer($ZCVT("лимузин", "O", "UTF8"))
		
		set retVal =  cna.CallFunction("Hunspell_spell", cna.#UINT, argTypes, hunspell, bad)
		do $$$AssertEquals(retVal, 0, "Incorrect word")
		
		set retVal =  cna.CallFunction("Hunspell_spell", cna.#UINT, argTypes, hunspell, good)
		do $$$AssertNotEquals(retVal, 0, "Correct word")
		
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestPointers">
<Implementation><![CDATA[
	try {
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(cna.#SIZET)
		
		set memory = cna.CallFunction("mal", cna.#POINTER, argTypes, 8)
		
		do cna.PointerSetAt(memory, cna.#UINT, 0, 12345678)		
		do cna.PointerSetAt(memory, cna.#UINT, 1, 1313)
		
		set mem0 = cna.PointerGetAt(memory, cna.#UINT, 0)
		do $$$AssertEquals(mem0, 12345678, "memory[0] must be equal to 12345678")
		
		set mem1 = cna.PointerGetAt(memory, cna.#UINT, 1)
		do $$$AssertEquals(mem1, 1313, "memory[1] must be equal to 1313")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#POINTER)
		
		do cna.CallFunction("fr", cna.#VOID, argTypes, memory)
		
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestIntegers">
<Implementation><![CDATA[
	try {
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)

		set argTypes = ##class(%ListOfDataTypes).%New()
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#UCHAR)
		set retVal = cna.CallFunction("_uchar", cna.#UCHAR, argTypes, $zhex("FD"))
		do $$$AssertEquals(retVal, $zhex("FD"), "Check uchar() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#SCHAR)
		set retVal = cna.CallFunction("_schar", cna.#SCHAR, argTypes, -3)
		do $$$AssertEquals(retVal, -3, "Check schar() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#USHORT)
		set retVal = cna.CallFunction("_ushort", cna.#USHORT, argTypes, $zhex("FFFD"))
		do $$$AssertEquals(retVal, $zhex("FFFD"), "Check ushort() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#SHORT)
		set retVal = cna.CallFunction("_sshort", cna.#SHORT, argTypes, -3)
		do $$$AssertEquals(retVal, -3, "Check sshort() return value")

		
		do argTypes.Clear()
		do argTypes.Insert(cna.#UINT)
		set retVal = cna.CallFunction("_uint", cna.#UINT, argTypes, $zhex("FFFFFFFD"))
		do $$$AssertEquals(retVal, $zhex("FFFFFFFD"), "Check uint() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#INT)
		set retVal = cna.CallFunction("_sint", cna.#INT, argTypes, -3)
		do $$$AssertEquals(retVal, -3, "Check sint() return value")

		
		do argTypes.Clear()
		do argTypes.Insert(cna.#ULONG)
		set retVal = cna.CallFunction("_ulong", cna.#ULONG, argTypes, $zhex("FFFFFFFD"))
		do $$$AssertEquals(retVal, $zhex("FFFFFFFD"), "Check ulong() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#LONG)
		set retVal = cna.CallFunction("_slong", cna.#LONG, argTypes, -3)
		do $$$AssertEquals(retVal, -3, "Check slong() return value")

		
		do argTypes.Clear()
		do argTypes.Insert(cna.#UINT64)
		set retVal = cna.CallFunction("_uint64", cna.#UINT64, argTypes, 1234567890)
		do $$$AssertEquals(retVal, 1234567890, "Check uint64() return value")
		
		do argTypes.Clear()
		do argTypes.Insert(cna.#INT64)
		set retVal = cna.CallFunction("_sint64", cna.#INT64, argTypes, -3)
		do $$$AssertEquals(retVal, -3, "Check sint64() return value")
		
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestStructures">
<Implementation><![CDATA[
	try {
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		set structType = ##class(%ListOfDataTypes).%New()
		do structType.Insert(cna.#SCHAR)
		do structType.Insert(cna.#INT64)
		do structType.Insert(cna.#SCHAR)
		do argTypes.Insert(structType)
		
		set structVal = ##class(%ListOfDataTypes).%New()
		do structVal.Insert(12)
		do structVal.Insert(2114)
		do structVal.Insert(74)
		
		set retVal = cna.CallFunction("sum_st", cna.#INT64, argTypes, structVal)
		do $$$AssertEquals(retVal, 2200, "Check return value of sum_st()")
		
		
		do argTypes.Clear()
		set retVal = cna.CallFunction("create_st", structType, argTypes)
		do $$$AssertEquals(retVal.GetAt(1), 1, "Check return value of create_st()")
		do $$$AssertEquals(retVal.GetAt(2), 2, "Check return value of create_st()")
		do $$$AssertEquals(retVal.GetAt(3), 3, "Check return value of create_st()")
		
		
		set nestedType = ##class(%ListOfDataTypes).%New()
		do nestedType.Insert(cna.#SCHAR)
		do nestedType.Insert(cna.#INT64)
		do nestedType.Insert(cna.#SCHAR)
		
		do structType.Clear()
		do structType.Insert(cna.#SCHAR)
		do structType.Insert(nestedType)
		do structType.Insert(cna.#SCHAR)
		
		do argTypes.Clear()
		do argTypes.Insert(structType)
		
		set nestedVal = ##class(%ListOfDataTypes).%New()
		do nestedVal.Insert(-14)
		do nestedVal.Insert(33100)
		do nestedVal.Insert(28)
		
		do structVal.Clear()
		do structVal.Insert(12)
		do structVal.Insert(nestedVal)
		do structVal.Insert(74)
		
		
		
		set retVal = cna.CallFunction("sum_nested", cna.#INT64, argTypes, structVal)
		do $$$AssertEquals(retVal, 33200, "Check return value of sum_nested()")
		
			
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestFloatingPoint">
<Implementation><![CDATA[
	try {
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(cna.#FLOAT)
		do argTypes.Insert(cna.#FLOAT)
		set retVal = cna.CallFunction("sum_float", cna.#FLOAT, argTypes, $double(0.2), $double(1.5))
		do $$$AssertEquals($zabs(retVal - $double(1.7)) < $double(0.0000001), 1, "Check return value of sum_float()")
		
		if ($SYSTEM.Version.GetOS() = "UNIX") {
			do argTypes.Clear()
			do argTypes.Insert(cna.#LONGDOUBLE)
			do argTypes.Insert(cna.#LONGDOUBLE)
			set retVal = cna.CallFunction("sum_long_double", cna.#LONGDOUBLE, argTypes, $double(0.2), $double(1.5))
			do $$$AssertEquals(retVal, $double(1.7), "Check return value of sum_long_double()")
		}
		
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="TestStreams">
<Implementation><![CDATA[
	try {
		set cna = ##class(CNA.CNA).%New(..CNAPath)
		do cna.LoadLibrary(..testLib)
		
		set file = ##class(%Stream.FileBinary).%New()	
		do file.LinkToFile(..Ulysses)
		
		set pointer = cna.ConvertStreamToPointer(file)
		set path = cna.ConvertStringToPointer(..Ulysses)
			
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(cna.#POINTER)
		do argTypes.Insert(cna.#POINTER)
		
		set retVal = cna.CallFunction("compare_string_and_ulysses", cna.#INT, argTypes, pointer, path)
		do $$$AssertEquals(retVal, 1, "Check retval")
		
		do cna.FreeLibrary()
	}catch ex {
		do cna.FreeLibrary()
		do $$$AssertEquals(0, 1, $system.Status.GetErrorText(ex.AsStatus()))
	}
]]></Implementation>
</Method>

<Method name="OnBeforeAllTests">
<Description><![CDATA[
Run by <B>RunTest</B> once <a href="#OnBeforeAll">before any test methods</a> in the test class are run. Can be used to set up a 
test environment that will be later cleaned up by <B>OnAfterAllTests</B>. 
<br><br>Example: Setup and Cleanup of an environment: 
<pre>
Method OnBeforeAllTests() As %Status
{
	//do setup stuff here
 	set ^inputMessage = "input message"
	quit $$$OK
}
Method OnAfterAllTests() As %Status
{
	//do clean up stuff here
	kill ^inputMessage
	quit $$$OK
}</pre>
]]></Description>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if ($SYSTEM.Version.GetOS() = "UNIX") {
		set delim = "/"
		set suffix = ".so"
	} else {
		set delim = "\"
		set suffix = ".dll"
	}
	set ..CNAPath = ^UnitTestRoot _ delim _ ".." _ delim _ "libcna" _ suffix
	set ..testLib = ^UnitTestRoot _ delim _ "libtest" _ suffix
	set hunspellDir = ^UnitTestRoot _ delim _ ".." _ delim _ ".." _ delim _ "hunspell" _ delim 
	set ..Hunspell = hunspellDir _ "libhunspell" _ suffix
	set ..HunspellAff = hunspellDir _ "ru_RU.aff"
	set ..HunspellDic = hunspellDir _ "ru_RU.dic"
	
	set ..Ulysses = ^UnitTestRoot _ delim _ ".." _ delim _ ".." _ delim _ "ulysses.txt"

 	Quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
