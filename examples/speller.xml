<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.1.1 (Build 702U)" ts="2014-08-27 16:08:01">
<Class name="CNA.Examples.Speller">
<StorageStrategy/>
<Super>%RegisteredObject</Super>
<TimeChanged>63426,57454.675906</TimeChanged>
<TimeCreated>63414,42098.211762</TimeCreated>

<Property name="CNA">
<Type>CNA.CNA</Type>
</Property>

<Property name="LibC">
<Type>CNA.CNA</Type>
</Property>

<Property name="Hunspell">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>CNAPath:%String,hunspellPath:%String,libcPath:%String,affPath:%String,dicPath:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		if (('$data(CNAPath)) || ('##class(%File).Exists(CNAPath))) {
			return $$$ERROR("CNA file doesn't exists")	
		}
		if (('$data(hunspellPath)) || ('##class(%File).Exists(hunspellPath))) {
			return $$$ERROR("hunspell file doesn't exists")	
		}
		if (('$data(libcPath)) || ('##class(%File).Exists(libcPath))) {
			return $$$ERROR("libc file doesn't exists")	
		}
		if (('$data(affPath)) || ('##class(%File).Exists(affPath))) {
			return $$$ERROR(".aff file doesn't exists")	
		}
		if (('$data(dicPath)) || ('##class(%File).Exists(dicPath))) {
			return $$$ERROR(".dic file doesn't exists")	
		}
		
		set ..CNA = ##class(CNA.CNA).%New(CNAPath)
		set ..LibC = ##class(CNA.CNA).%New(CNAPath)
		
		do ..CNA.LoadLibrary(hunspellPath)
		do ..LibC.LoadLibrary(libcPath)
		
		set aff = ..CNA.ConvertStringToPointer(affPath)
		set dic = ..CNA.ConvertStringToPointer(dicPath)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(..CNA.#POINTER)
		do argTypes.Insert(..CNA.#POINTER)
		
		set ..Hunspell =  ..CNA.CallFunction("Hunspell_create", ..CNA.#POINTER, argTypes, aff, dic)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(..CNA.#POINTER)
		do ..CNA.CallFunction("Hunspell_destroy", ..CNA.#VOID, argTypes, ..Hunspell)
		do ..CNA.FreeLibrary()
		do ..LibC.FreeLibrary()
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="Spell">
<Description>
True - correct word, false - incorrect word</Description>
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set pWord = ..CNA.ConvertStringToPointer(word)
	set argTypes = ##class(%ListOfDataTypes).%New()
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	set res = ..CNA.CallFunction("Hunspell_spell", ..CNA.#INT, argTypes, ..Hunspell, pWord)
	return res
]]></Implementation>
</Method>

<Method name="Suggest">
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
	set pWord = ..CNA.ConvertStringToPointer(word)
	
	set argTypes = ##class(%ListOfDataTypes).%New()
	do argTypes.Insert(..CNA.#SIZET)
	set pArray = ..LibC.CallFunction("malloc", ..LibC.#POINTER, argTypes, 8)
	
	do argTypes.Clear()
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	set numberOfSuggestions = ..CNA.CallFunction("Hunspell_suggest", ..CNA.#INT, argTypes, ..Hunspell, pArray, pWord)

	set suggestions = ##class(%ListOfDataTypes).%New()
	set array = ..CNA.PointerGetAt(pArray, ..CNA.#POINTER, 0)
	
	for i=1:1:numberOfSuggestions {
		set elem = ..CNA.PointerGetAt(array, ..CNA.#POINTER, i - 1)
		do suggestions.Insert(..CNA.ConvertPointerToString(elem))
	}
	
	do argTypes.Clear()
	do argTypes.Insert(..CNA.#POINTER)
	do ..LibC.CallFunction("free", ..LibC.#VOID, argTypes, pArray)
	
	return suggestions
]]></Implementation>
</Method>

<Method name="CheckRuString">
<FormalSpec>str:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set translated = $TRANSLATE(str, ",\/=*:", "      ")
	set stripped =  $ZSTRIP(translated, "*E", "", " -йцукеёнгшщзхъфывапролджэячсмитьбюЙЦУКЕЁНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ")
	set list = $LFS(stripped, " ")
						
	set ptr = 0
	set count = 0
	while $LISTNEXT(list, ptr, value) {
		set word = $ZSTRIP(value, "<>W", "-")
		if (word '= "") {
			if (..Spell(word) = 0) {
				set count = count + 1
				w word, " "
			}
		}			
	}
	if (count > 0) {
		w ?90, "<< """ _ str _ """", !	
	}
	return count
]]></Implementation>
</Method>

<Method name="CheckLocalization">
<FormalSpec>global="^CacheMsg",file="mistakes.txt"</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set key = ""
	set count = 0
	open file:"NWS":5
	use file
	while(1) {
		set key = $ORDER(@global@(key))
		if (key = "") {
			quit
		}
		if ($data(@global@(key, "ru"))) {
			set nestedKey = ""
			do {
				set nestedKey = $ORDER(@global@(key, "ru", nestedKey))
				if (nestedKey = "") { 
					quit
				}
				set str =  @global@(key, "ru", nestedKey)
				set count = count + ..CheckRuString(str)

				
			} while (nestedKey '= "")
		}
	}
	
	w !, "Ошибок - " _ count, !
	close file
	return count
]]></Implementation>
</Method>

<Method name="CheckSystemLocalization">
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[	return ..CheckLocalization("^%qCacheMsg")
]]></Implementation>
</Method>
</Class>
</Export>
