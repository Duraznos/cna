<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.1.1 (Build 702U)" ts="2014-08-18 15:56:38">
<Class name="CNA.Examples.Speller">
<StorageStrategy/>
<Super>%RegisteredObject</Super>
<TimeChanged>63417,57316.062806</TimeChanged>
<TimeCreated>63414,42098.211762</TimeCreated>

<Property name="CNA">
<Type>CNA.CNA</Type>
</Property>

<Property name="LibC">
<Type>CNA.CNA</Type>
</Property>

<Property name="Hunspell">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>CNAPath:%String,hunspellPath:%String,libcPath:%String,affPath:%String,dicPath:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		if (('$data(CNAPath)) || ('##class(%File).Exists(CNAPath))) {
			return $$$ERROR("CNA file doesn't exists")	
		}
		if (('$data(hunspellPath)) || ('##class(%File).Exists(hunspellPath))) {
			return $$$ERROR("hunspell file doesn't exists")	
		}
		if (('$data(libcPath)) || ('##class(%File).Exists(libcPath))) {
			return $$$ERROR("libc file doesn't exists")	
		}
		if (('$data(affPath)) || ('##class(%File).Exists(affPath))) {
			return $$$ERROR(".aff file doesn't exists")	
		}
		if (('$data(dicPath)) || ('##class(%File).Exists(dicPath))) {
			return $$$ERROR(".dic file doesn't exists")	
		}
		
		set ..CNA = ##class(CNA.CNA).%New(CNAPath)
		set ..LibC = ##class(CNA.CNA).%New(CNAPath)
		
		do ..CNA.LoadLibrary(hunspellPath)
		do ..LibC.LoadLibrary(libcPath)
		
		set aff = ..CNA.ConvertStringToPointer(affPath)
		set dic = ..CNA.ConvertStringToPointer(dicPath)
		
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(..CNA.#POINTER)
		do argTypes.Insert(..CNA.#POINTER)
		
		set ..Hunspell =  ..CNA.CallFunction("Hunspell_create", ..CNA.#POINTER, argTypes, aff, dic)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	
	Quit $$$OK

]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<ServerOnly>1</ServerOnly>
<Implementation><![CDATA[
	try {
		set argTypes = ##class(%ListOfDataTypes).%New()
		do argTypes.Insert(..CNA.#POINTER)
		do ..CNA.CallFunction("Hunspell_destroy", ..CNA.#VOID, argTypes, ..Hunspell)
		do ..CNA.FreeLibrary()
		do ..LibC.FreeLibrary()
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK

]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// True - correct word, false - incorrect word

]]></Content>
</UDLText>

<Method name="Spell">
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set pWord = ..CNA.ConvertStringToPointer(word)
	set argTypes = ##class(%ListOfDataTypes).%New()
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	set res = ..CNA.CallFunction("Hunspell_spell", ..CNA.#INT, argTypes, ..Hunspell, pWord)
	return res

]]></Implementation>
</Method>

<Method name="Suggest">
<FormalSpec>word:%String</FormalSpec>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
	set pWord = ..CNA.ConvertStringToPointer(word)
	
	set argTypes = ##class(%ListOfDataTypes).%New()
	do argTypes.Insert(..CNA.#SIZET)
	set pArray = ..LibC.CallFunction("malloc", ..LibC.#POINTER, argTypes, 8)
	
	do argTypes.Clear()
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	do argTypes.Insert(..CNA.#POINTER)
	set numberOfSuggestions = ..CNA.CallFunction("Hunspell_suggest", ..CNA.#INT, argTypes, ..Hunspell, pArray, pWord)

	set suggestions = ##class(%ListOfDataTypes).%New()
	set array = ..CNA.PointerGetAt(pArray, ..CNA.#POINTER, 0)
	
	for i=1:1:numberOfSuggestions {
		set elem = ..CNA.PointerGetAt(array, ..CNA.#POINTER, i - 1)
		do suggestions.Insert(..CNA.ConvertPointerToString(elem))
	}
	
	do argTypes.Clear()
	do argTypes.Insert(..CNA.#POINTER)
	do ..LibC.CallFunction("free", ..LibC.#VOID, argTypes, pArray)
	
	return suggestions

]]></Implementation>
</Method>

<Method name="CheckLocalization">
<Implementation><![CDATA[
	set key = ""
	set count = 0
	open "mistakes.txt":"NWS":5
	use "mistakes.txt"
	while(1) {
		set key = $ORDER(^%qCacheMsg(key))
		if (key = "") {
			quit
		}
		if ($data(^%qCacheMsg(key, "ru"))) {
			set nestedKey = ""
			do {
				set nestedKey = $ORDER(^%qCacheMsg(key, "ru", nestedKey))
				if (nestedKey = "") { 
					quit
				}
				set str =  ^%qCacheMsg(key, "ru", nestedKey)
				
				set translated = $TRANSLATE(str, ",\/=*:", "      ")
				set stripped =  $ZSTRIP(translated, "*E", "", " -йцукеёнгшщзхъфывапролджэячсмитьбюЙЦУКЕЁНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮ")
				set list = $LFS(stripped, " ")
				
				
				
				set ptr = 0
				set flag = 0
				while $LISTNEXT(list, ptr, value) {
					set word = $ZSTRIP(value, "<>W", "-")
					if (word '= "") {
						if (..Spell(word) = 0) {
							if (flag = 0) {
								w !, "Ошибки:"
								set flag = 1
								set count = count + 1
							}
							w " " _ word
						}
					}			
				}
				if (flag) {
					w !, $ZR _ " = """ _ str _ """", !	
				}
				
			} while (nestedKey '= "")
		}
	}
	w !, "Ошибок - " _ count, !
	close "mistakes.txt"

]]></Implementation>
</Method>
</Class>
</Export>
