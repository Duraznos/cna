<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25" zv="Cache for Windows (x86-64) 2014.1.1 (Build 702U)" ts="2014-07-28 13:01:51">
<Class name="CNA.CNA">
<Super>%RegisteredObject</Super>
<TimeChanged>63393,61635.561024</TimeChanged>
<TimeCreated>63383,58144.669569</TimeCreated>

<Property name="LibId">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="CNAId">
<Type>%Integer</Type>
<Private>1</Private>
</Property>

<Property name="TypeSizes">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Alignments">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AllocatedMemory">
<Type>%ListOfDataTypes</Type>
<Private>1</Private>
</Property>

<Parameter name="VOID">
<Default>0</Default>
</Parameter>

<Parameter name="UCHAR">
<Default>1</Default>
</Parameter>

<Parameter name="SCHAR">
<Default>2</Default>
</Parameter>

<Parameter name="UINT">
<Default>3</Default>
</Parameter>

<Parameter name="INT">
<Default>4</Default>
</Parameter>

<Parameter name="USHORT">
<Default>5</Default>
</Parameter>

<Parameter name="SHORT">
<Default>6</Default>
</Parameter>

<Parameter name="ULONG">
<Default>7</Default>
</Parameter>

<Parameter name="LONG">
<Default>8</Default>
</Parameter>

<Parameter name="UINT64">
<Default>9</Default>
</Parameter>

<Parameter name="INT64">
<Default>10</Default>
</Parameter>

<Parameter name="FLOAT">
<Default>11</Default>
</Parameter>

<Parameter name="DOUBLE">
<Default>12</Default>
</Parameter>

<Parameter name="LONGDOUBLE">
<Default>13</Default>
</Parameter>

<Parameter name="POINTER">
<Default>14</Default>
</Parameter>

<Parameter name="SIZET">
<Default>15</Default>
</Parameter>

<Parameter name="STRUCT">
<Default>16</Default>
</Parameter>

<Parameter name="NTYPES">
<Default>17</Default>
</Parameter>

<Method name="ThrowMessage">
<ClassMethod>1</ClassMethod>
<FormalSpec>msg:%String</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	set st = $$$ERROR($$$GeneralError, msg)
	throw ##class(%Exception.StatusException).CreateFromStatus(st)
]]></Implementation>
</Method>

<Method name="CreateStructType">
<ClassMethod>1</ClassMethod>
<FormalSpec>types:%ListOfDataTypes</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set structType = $CHAR(..#STRUCT, types.Size)
	for i=1:1:types.Size {
		set type = types.GetAt(i)
		set structType = structType _ ..ConvertTypeFromCacheToCNA(type)
	}
	return structType
]]></Implementation>
</Method>

<Method name="ConvertTypeFromCacheToCNA">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if ($ISOBJECT(type)) {
		return ..CreateStructType(type)	
	} else {
		return $CHAR(type)
	}
]]></Implementation>
</Method>

<Method name="GetAlignments">
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set os = $SYSTEM.Version.GetOS()
	set platform = $SYSTEM.Version.GetPlatform()
	
	set aligns = ""
	for i=0:1:(..#NTYPES - 2) {
		if (((i = ..#DOUBLE) || (i = ..#LONGDOUBLE)) && (os = "UNIX") && (platform = "x86-32")) {
			set aligns = aligns _ $CHAR(4)
		} else {
			set aligns = aligns _ $CHAR($ASCII(..TypeSizes, i + 1))
		} 
	}
	return aligns
]]></Implementation>
</Method>

<Method name="ApplyAlignment">
<FormalSpec><![CDATA[&memory:%String,&offset:%Integer,alignment:%Integer]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	set padding = (alignment - (offset # alignment)) # alignment
	if ($data(memory)) {
		for j=1:1:padding {
			set memory = memory _ $CHAR(0)
		}
	}
	set offset = offset + padding
]]></Implementation>
</Method>

<Method name="GetSizeAndAlignment">
<FormalSpec>type,*size:%Integer,*alignment:%Integer</FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
	if ($ISOBJECT(type)) {
		set alignment = 0
		set offset = 0
		for i=1:1:type.Size {
			do ..GetSizeAndAlignment(type.GetAt(i), .elemSize, .elemAlign)
			if (elemAlign > alignment) {
				set alignment = elemAlign	
			}
			do ..ApplyAlignment( , .offset, elemAlign)
			set offset = offset + elemSize
		}
		do ..ApplyAlignment( , .offset, alignment)
		set size = offset
		
	} else {
		set size = $ASCII(..TypeSizes, type + 1)
		set alignment = $ASCII(..Alignments, type + 1)		
	}
]]></Implementation>
</Method>

<Method name="CheckStructSupport">
<Private>1</Private>
<Implementation><![CDATA[
	set os = $SYSTEM.Version.GetOS()
	set platform = $SYSTEM.Version.GetPlatform()
	
	if (((os '= "UNIX") && (os '= "Windows")) || ((platform '= "x86-32") && (platform '= "x86-64"))) {
		do ..ThrowMessage("Structures are unsupported on your platform")
	}
]]></Implementation>
</Method>

<Method name="ConvertStructFromCacheToCNA">
<FormalSpec>type:%ListOfDataTypes,values:%ListOfDataTypes</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	do ..CheckStructSupport()
	
	set struct = ""
	set maxAlign = 0
	set offset = 0
	
	for i=1:1:values.Size {
		set elemType = type.GetAt(i)
		do ..GetSizeAndAlignment(elemType, .elemSize, .elemAlign)
		
		if (elemAlign > maxAlign) {
			set maxAlign = elemAlign	
		}
		
		do ..ApplyAlignment(.struct, .offset, elemAlign)
		
		set offset = offset + elemSize
		set struct = struct _ ..ConvertFromCacheToCNA(elemType, values.GetAt(i))
	}
	
	do ..ApplyAlignment(.struct, .offset, maxAlign)
		
	return struct
]]></Implementation>
</Method>

<Method name="ConvertStructFromCNAToCache">
<FormalSpec>type:%String,struct:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
	set aligns = ..GetAlignments()
	set values = ##class(%ListOfDataTypes).%New()
	set offset = 0
	for i=1:1:type.Size {
		set elemType = type.GetAt(i)
		set elemSize = $ASCII(..TypeSizes, elemType + 1)
		set elemAlign = $ASCII(aligns, elemType + 1)
		
		set padding = (elemAlign - (offset # elemAlign)) # elemAlign
		set offset = offset + padding + elemSize
		do values.Insert(..ConvertFromCNAToCache(elemType, $EXTRACT(struct, offset - elemSize + 1, offset + 1)))

	}	
	return values
]]></Implementation>
</Method>

<Method name="SignedToUnsigned">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Integer,size:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set max = $case(size, 1:"7F", 2:"7FFF", 4:"7FFFFFFF", 8:"7FFFFFFFFFFFFFFF")
	set minusOne = $case(size, 1:"FF", 2:"FFFF", 4:"FFFFFFFF", 8:"FFFFFFFFFFFFFFFF")
	
	if ((value > $zhex(max)) || (value <= - $zhex(max))) {
		do ..ThrowMessage("Illegal value")
	} 
	if (value < 0) {
		set value = $zhex(minusOne) + value + 1
	}
	return value
]]></Implementation>
</Method>

<Method name="UnsignedToSigned">
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%Integer,size:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set max = $case(size, 1:"7F", 2:"7FFF", 4:"7FFFFFFF", 8:"7FFFFFFFFFFFFFFF")
	set minusOne = $case(size, 1:"FF", 2:"FFFF", 4:"FFFFFFFF", 8:"FFFFFFFFFFFFFFFF")
	
	if ((value < 0) || (value > $zhex(minusOne))) {
		do ..ThrowMessage("Illegal Value")
	}
	if (value > $zhex(max)) {
		set value = value - $zhex(minusOne) - 1
	}
	return value
]]></Implementation>
</Method>

<Method name="ConvertIntegerFromCacheToCNA">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%Integer,size:%Integer,value:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set isUnsigned = (type = ..#UCHAR ) || 
	                 (type = ..#UINT  ) ||
	                 (type = ..#USHORT) ||
	                 (type = ..#ULONG ) ||
	                 (type = ..#SIZET ) ||
	                 (type = ..#UINT64)
	
	if (('isUnsigned) && ((size = 1) || (size = 2) || (size = 4))) {
		set value = ..SignedToUnsigned(value, size)
	} elseif (isUnsigned && (size = 8)) {
		//set value = ..UnsignedToSigned(value, size)
		//TODO: and support for uint64
	}
	
	return $case(size, 1:$CHAR(value), 2:$ZWCHAR(value), 4:$ZLCHAR(value), 8:$ZQCHAR(value))
]]></Implementation>
</Method>

<Method name="ConvertIntegerFromCNAToCache">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,size:%Integer,value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	set isUnsigned = (type = ..#UCHAR ) || 
	                 (type = ..#UINT  ) ||
	                 (type = ..#USHORT) ||
	                 (type = ..#ULONG ) ||
	                 (type = ..#SIZET ) ||
	                 (type = ..#UINT64)
	                 
	set value = $case(size, 1:$ASCII(value), 2:$ZWASCII(value), 4:$ZLASCII(value), 8:$ZQASCII(value))
	
	if (('isUnsigned) && ((size = 1) || (size = 2) || (size = 4))) {
		set value = ..UnsignedToSigned(value, size)
	} elseif (isUnsigned && (size = 8)) {
		//set value = ..SignedToUnsigned(value, size)
		//TODO: and support for uint64
	}
	
	return value
]]></Implementation>
</Method>

<Method name="ConvertFromCacheToCNA">
<FormalSpec>type:%String,value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (type >= ..#NTYPES) {
			do ..ThrowMessage("Incorrect type")	
	}
	set size = $ASCII(..TypeSizes, type + 1)
			
	if ((type = ..#FLOAT) || (type = ..#LONGDOUBLE)) {
		do ..ThrowMessage("#FLOAT and #LONGDOUBLE is unsupported")	
	}elseif (type = ..#DOUBLE) {
		set cnaVal = $ZDCHAR(value)
	}elseif (type = ..#POINTER) {
		set cnaVal = value
	}elseif (type = ..#VOID) {
		do ..ThrowMessage("#VOID may be used only for the type of return value")
	}elseif ($ISOBJECT(type)) {
		set cnaVal = ..ConvertStructFromCacheToCNA(type, value)
	}else {
		set cnaVal = ..ConvertIntegerFromCacheToCNA(type, size, value)
	}
	if (cnaVal = "") {
		do ..ThrowMessage("Illegal value or unsupported size of numeric type")
	}
	return cnaVal
]]></Implementation>
</Method>

<Method name="ConvertFromCNAToCache">
<FormalSpec>type:%Integer,value:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if (type >= ..#NTYPES) {
			do ..ThrowMessage("Incorrect type")	
	}
	set size = $ASCII(..TypeSizes, type + 1)
	if ((type = ..#FLOAT) || (type = ..#LONGDOUBLE)) {
		do ..ThrowMessage("Unsupported type of return value")
	}elseif (type = ..#DOUBLE) {
		set returnValue = $ZDASCII(value)
	}elseif (type = ..#POINTER) {
		set returnValue = value
	}elseif (type = ..#VOID) {
		set returnValue = ""
	}elseif ($ISOBJECT(type)) {
		set returnValue = ..ConvertStructFromCNAToCache(type, value)
	}else {
		set returnValue = ..ConvertIntegerFromCNAToCache(type, size, value)
	}
	return returnValue
]]></Implementation>
</Method>

<Method name="CallFunction">
<FormalSpec>name:%String,returnType:%Integer,*returnValue:%String,argTypes:%ListOfDataTypes,args...:%List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set callFunc = $zf(-4, 3, ..CNAId, "call_function")
		if ('$data(args)) {
			set args = 0
		}
		if (argTypes.Size '= args) {
			do ..ThrowMessage("Size of collection of argument types and number of arguments must be equal.")
		}
		set cnaArgTypes = ""
		set cnaArgs = ""
		
		for i = 1:1:args {
			set val = $GET(args(i))
			set type = argTypes.GetAt(i)
			
			
			if ($ISOBJECT(type)) {
				do ..GetSizeAndAlignment(type, .size, .alignment) 
				set cnaArgs = cnaArgs _ ..ConvertIntegerFromCacheToCNA(..#SIZET, $ASCII(..TypeSizes, ..#SIZET + 1), size)
			}
			
			set cnaArgs = cnaArgs _ ..ConvertFromCacheToCNA(type, val)
			set cnaArgTypes = cnaArgTypes _ ..ConvertTypeFromCacheToCNA(type)
		}
		set cnaArgTypes = cnaArgTypes _ ..ConvertTypeFromCacheToCNA(returnType)
		set cnaRet = $zf(-5, ..CNAId, callFunc, ..LibId, name, cnaArgTypes, cnaArgs)
				
		set returnValue =  ..ConvertFromCNAToCache(returnType, cnaRet)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="LoadLibrary">
<FormalSpec>path:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set loadLib = $zf(-4, 3, ..CNAId, "load_library")
		set ..LibId = $zf(-5, ..CNAId, loadLib, path)
	}catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="FreeLibrary">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set freeLib = $zf(-4, 3, ..CNAId, "free_library")
		do $zf(-5, ..CNAId, freeLib, ..LibId)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnNew">
<FormalSpec>CNAPath:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	
	if (('$data(CNAPath)) || ('##class(%File).Exists(CNAPath))) {
		do ..ThrowMessage("CNA file doesn't exists")	
	}
	
	try {
		set ..CNAId = $zf(-4, 1, CNAPath)
		set getSizes = $zf(-4, 3, ..CNAId, "get_sizes")
		set ..TypeSizes = $zf(-5, ..CNAId, getSizes)
		set ..Alignments = ..GetAlignments()
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set s2p = $zf(-4, 3, ..CNAId, "free_pointer")
		for i=1:1:..AllocatedMemory.Size {
			do $zf(-5, ..CNAId, s2p, ..AllocatedMemory.GetAt(i))		
		}

		do $zf(-4, 2, ..CNAId)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="PointerGetAt">
<Description>
Access to array element. Operating with pointers may be unsafe!</Description>
<FormalSpec>pointer:%String,type:%Integer,index:%Integer,*value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
	  set getAt = $zf(-4, 3, ..CNAId, "pointer_get_at")
	  set cnaIndex = ..ConvertFromCacheToCNA(..#SIZET, index)
	  set cnaVal = $zf(-5, ..CNAId, getAt, pointer, $CHAR(type), cnaIndex)
	  
	  set value = ..ConvertFromCNAToCache(type, cnaVal)
	} catch ex {
		do ex.Log()
		return ex.AsStatus()	
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="PointerSetAt">
<Description>
Assigning to array element. Operating with pointers may be unsafe!</Description>
<FormalSpec>pointer:%String,type:%Integer,index:%Integer,value:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
	  set setAt = $zf(-4, 3, ..CNAId, "pointer_set_at")
	  set cnaVal = ..ConvertFromCacheToCNA(type, value)
	  set cnaIndex = ..ConvertFromCacheToCNA(..#SIZET, index)
	  do $zf(-5, ..CNAId, setAt, pointer, $CHAR(type), cnaIndex, cnaVal)
	  
	} catch ex {
		do ex.Log()
		return ex.AsStatus()	
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="ConvertStringToPointer">
<FormalSpec>string:%String,*pointer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	try {
		set s2p = $zf(-4, 3, ..CNAId, "string_to_pointer")
		set pointer = $zf(-5, ..CNAId, s2p, string)
		do ..AllocatedMemory.Insert(pointer)
	}catch ex {
		do ex.Log()
		return ex.AsStatus()
	}
	Quit $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
